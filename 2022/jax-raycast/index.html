<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Simple 3D visualization with JAX raycasting</title>
<meta name="description" content="Tutorial on rendering simple 3D scenes with JAX raycasting"/>
<meta property="article:author" content="Alexander Mordvintsev">
<link rel="icon" type="image/png" sizes="32x32" href="/self-organising-systems/assets/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/self-organising-systems/assets/img/favicon-16x16.png">
<link rel="stylesheet" href="highlight.css">
<link rel="stylesheet" href="style.css">

<!--  https://dev.twitter.com/cards/types/summary -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple 3D visualization with JAX raycasting">
<meta name="twitter:description" content="Tutorial on rendering simple 3D scenes with JAX raycasting>
<meta name="twitter:url" content="https://google-research.github.io/self-organising-systems/2022/jax-raycast/">
<meta name="twitter:image" content="https://google-research.github.io/self-organising-systems/2022/jax-raycast/08.jpeg">
<meta name="twitter:image:width" content="640">
<meta name="twitter:image:height" content="400">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NXJWS6Y0G1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NXJWS6Y0G1');
</script>
<h1>Simple 3D visualization with JAX raycasting</h1>
<p><a href="https://znah.net">Alexander Mordvintsev</a> | <a href="https://ai.google/">Google</a> | September 23, 2022</p>
<p><a href="https://colab.research.google.com/github/google-research/self-organising-systems/blob/master/notebooks/jax_raycast.ipynb" target="_blank" class="colab-root">Reproduce in a <span class="colab-span">Notebook</span></a></p>
<p>Recently I was using JAX to model a few particles moving and interacting in 3D space. Naturally, at some point I wanted to see the behavior of these particles along with some information about their state and interactions with my own eyes. Visualization options available to a researcher are plentiful today, but in the spirit of minimalism I decided to build a visualization with the same tools I was using to make the model. What surprised me was: the effort it took to get a reasonable 3D rendering and the amount of code I had to write was comparable to the amount of code needed to integrate a traditional graphics framework. In principle, I got a working tool for simple 3D scene visualization.</p>
<p>The rendering approach I took is based on raycasting <a href="https://iquilezles.org/articles/distfunctions/">Signed Distance Fields (SDF)</a>. <a href="https://iquilezles.org/">Inigo Quilez</a> popularized this approach and made <a href="https://www.shadertoy.com/">ShaderToy</a>, a thriving creative community of GPU shader developers. <a href="https://www.matthewtancik.com/nerf">Neural Rendering Fields</a> and <a href="https://www.youtube.com/watch?v=7LU0KcnSTc4">Differentiable Rendering</a> brought these ideas into machine learning world. There are a number of good SDF tutorials on the internet, including a <a href="https://blog.evjang.com/2019/11/jaxpt.html">blog post</a> by Eric Jang, who also used JAX. I recommend having a look at them to get the basic understanding of SDF raycasting before reading further. In this tutorial I'd like to make emphasis on the simplicity and flexibility of using this approach in practice.</p>
<p>The scenes we‚Äôll render consist of a few colored balls. I'm very excited about the underlying experiments which I originally set out to visualise, but that work is not yet ready for the publication, so let's generate some random dummies instead üòâ</p>
<code-cell><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">import</span> <span class="nn">jax.numpy</span> <span class="k">as</span> <span class="nn">jp</span>

<span class="k">class</span> <span class="nc">Balls</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="n">pos</span><span class="p">:</span> <span class="n">jp</span><span class="o">.</span><span class="n">ndarray</span>
  <span class="n">color</span><span class="p">:</span> <span class="n">jp</span><span class="o">.</span><span class="n">ndarray</span>

<span class="k">def</span> <span class="nf">create_balls</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
  <span class="n">pos</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
  <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">R</span>
  <span class="k">return</span> <span class="n">Balls</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>

<span class="n">key</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">PRNGKey</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="n">balls</span> <span class="o">=</span> <span class="n">create_balls</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>

</code-cell><p>Now we can define an SDF-function. For a given point <code>p</code> it returns a lower bound of the distance to the scene surface, positive for points outside of objects and negative inside. The function below computes distances from a given location to all balls and returns the minimum distance. We can use <code>jax.vmap</code> to sample many different locations in parallel, for example to quickly render 2D slices of a 3D SDF (see the <a href="https://colab.research.google.com/github/google-research/self-organising-systems/blob/master/notebooks/jax_raycast.ipynb#scrollTo=T4qykcQt8w4S" target="_blank"><code>show_slice</code></a> function in the notebook linked at the top of the page). Other helper functions I'll use in this tutorial are L2-norm computation (<code>norm</code> and <code>normalize</code>) and <code>animate</code> to generate videos.</p>
<code-cell><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">balls_sdf</span><span class="p">(</span><span class="n">balls</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ball_r</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
  <span class="n">dists</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">balls</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span><span class="o">-</span><span class="n">ball_r</span>
  <span class="k">return</span> <span class="n">dists</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">balls_sdf</span><span class="p">,</span> <span class="n">balls</span><span class="p">))(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>

<span class="n">show_slice</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">balls_sdf</span><span class="p">,</span> <span class="n">balls</span><span class="p">),</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">);</span>
</pre></div>

<div class="output"><pre>(1000,)
</pre></div>
<img src="00.png"></code-cell><p>SDF raycasting makes it easy to achieve effects that are non-trivial to implement with traditional methods. For example, I would like to merge nearby balls to emphasize their interaction (the effect known as <a href="https://en.wikipedia.org/wiki/Metaballs">metaballs</a>). With polygonal graphics this would require triangulating the isosurface (e.g. using <a href="https://en.wikipedia.org/wiki/Marching_cubes">marching cubes</a> algorithm), but here we can smooth the balls by simply replacing the <code>min</code> function with a variant of <a href="https://iquilezles.org/articles/smin/">softmin</a> (decreasing the parameter <code>c</code> makes smoothing stronger). Also I added a floor to the scene:</p>
<code-cell><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scene_sdf</span><span class="p">(</span><span class="n">balls</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ball_r</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">8.0</span><span class="p">):</span>
  <span class="n">dists</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">balls</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span><span class="o">-</span><span class="n">ball_r</span>
  <span class="n">balls_dist</span> <span class="o">=</span> <span class="o">-</span><span class="n">jax</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">(</span><span class="o">-</span><span class="n">dists</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>  <span class="c1"># softmin</span>
  <span class="n">floor_dist</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">3.0</span>  <span class="c1"># floor is at y==-3.0</span>
  <span class="k">return</span> <span class="n">jp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">balls_dist</span><span class="p">,</span> <span class="n">floor_dist</span><span class="p">)</span>  
  
<span class="n">show_slice</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">scene_sdf</span><span class="p">,</span> <span class="n">balls</span><span class="p">),</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>

<img src="01.png"></code-cell><p>Raycasting SDFs is very easy to implement. Given a starting point <code>p0</code> and a unit-length ray direction <code>dir</code> we make a series of jumps, where the length of each jump equals the minimum distance to the surface. The function below returns the point that the ray reaches after <code>step_n</code> iterations. This point is supposed to be close to the scene surface for rays that hit it, and somewhere far away from the scene for rays that miss the surface.</p>
<code-cell><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">raycast</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">step_n</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">+</span><span class="n">sdf</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="nb">dir</span>
  <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">fori_loop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">step_n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">p0</span><span class="p">)</span>
</pre></div>

</code-cell><p>You may notice that I'm using <code>jax.lax.fori_loop</code> instead of a python loop. Otherwise, applying <code>@jax.jit</code> decorator to this function would cause the loop body, including all nested calls, to be unrolled <code>step_n</code> times. This would substantially slow down the compilation, and might be the reason for very long compilation times reported <a href="‚Äã‚Äãhttps://blog.evjang.com/2019/11/jaxpt.html">in this post</a>.</p>
<p>Another important limitation is the fixed number of loop steps. Unfortunately, JAX doesn't allow dynamic loops in jitted code (and later we‚Äôll see that <code>jit</code> is really worth it when it comes to improving the rendering performance). In practice, some rays are going to escape the scene quickly, while others will quickly reach the surface. Only a fraction of surface-tangent rays would need that many steps. In GPU shader programming, groups of nearby rays are batched into blocks that are scheduled independently. Threads may have dynamic stopping conditions, so some blocks may finish earlier, releasing resources to work on slower blocks. The NumPy-inspired JAX (also TF and PyTorch) programming model is much less flexible in this regard.</p>
<p>Now when we can cast individual rays, we need to create a ray for each image pixel and cast them all together. <code>camera_rays</code> function calculates ray vectors given the camera direction, view size and field-of-view parameter.</p>
<code-cell><div class="highlight"><pre><span></span><span class="n">world_up</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">camera_rays</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">view_size</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
  <span class="n">right</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">world_up</span><span class="p">)</span>
  <span class="n">down</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">forward</span><span class="p">)</span>
  <span class="n">R</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">right</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">forward</span><span class="p">]))</span>
  <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">view_size</span>
  <span class="n">fy</span> <span class="o">=</span> <span class="n">fx</span><span class="o">/</span><span class="n">w</span><span class="o">*</span><span class="n">h</span>
  <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">fy</span><span class="p">:</span><span class="o">-</span><span class="n">fy</span><span class="p">:</span><span class="n">h</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="n">fx</span><span class="p">:</span><span class="n">fx</span><span class="p">:</span><span class="n">w</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">jp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span> <span class="o">@</span> <span class="n">R</span>

<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">400</span>
<span class="n">pos0</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">])</span>
<span class="n">ray_dir</span> <span class="o">=</span> <span class="n">camera_rays</span><span class="p">(</span><span class="o">-</span><span class="n">pos0</span><span class="p">,</span> <span class="n">view_size</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>
<span class="n">sdf</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">scene_sdf</span><span class="p">,</span> <span class="n">balls</span><span class="p">)</span>
<span class="n">hit_pos</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">raycast</span><span class="p">,</span> <span class="n">sdf</span><span class="p">,</span> <span class="n">pos0</span><span class="p">))(</span><span class="n">ray_dir</span><span class="p">)</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">hit_pos</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>

<img src="02.jpeg"></code-cell><p>Hoo<strong>ray</strong>, we can already see something! Ray endpoints are stored in the <code>hit_pos</code> array and the image above shows fractional parts of their XYZ coordinates as RGB colors.</p>
<h2>Shading and coloring</h2>
<p>Our visual system is very good at estimating the shape of objects from the interplay of light and shadows, so shading is an important part of visualization. Whatever shading model we decide to apply, we have to know the surface normals in order to estimate how much light it receives and reflects. Luckly, SDFs and automated differentiation give us an easy way to get them: the normal is the gradient of the SDF function.</p>
<code-cell><div class="highlight"><pre><span></span><span class="n">raw_normal</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">sdf</span><span class="p">))(</span><span class="n">hit_pos</span><span class="p">)</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">raw_normal</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>

<img src="03.jpeg"></code-cell><p>You may notice that I saved the SDF gradient as <code>raw_normal</code>. The gradient of a perfect SDF function is a unit-length vector orthogonal to the isosurface at the current point. Our SDF is a little bit ‚Äúimperfect‚Äù because of the ad-hoc smoothing with the soft-min function, which can make the gradient norm smaller than one in some areas. Shall we just correct this imperfection by "normalizing" normals and move on? There's something more interesting we can do! Let's look at the norms of our gradients:</p>
<code-cell><div class="highlight"><pre><span></span><span class="n">imshow</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">raw_normal</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
</pre></div>

<img src="04.jpeg"></code-cell><p>Gradient norms are smaller at concave areas of the surface. In real life, we have a phenomenon, that concave areas receive less ambient light because of occlusion, or are less shiny because they accumulate more dust over time. This gives a strong cue to our visual system, and the artifact of normal estimation gives us a way to approximately simulate this effect almost for free!</p>
<p>Direct light shadows are another important depth cue. We can simulate them by casting secondary rays from the surface towards the light source. Using SDFs we can even fake soft shadows with a single raycast. Please refer to this great <a href="https://iquilezles.org/articles/rmshadows/">blog post</a> by Inigo Quilez for the details.</p>
<code-cell><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cast_shadow</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">light_dir</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">step_n</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">hardness</span><span class="o">=</span><span class="mf">8.0</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">carry</span><span class="p">):</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">carry</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">(</span><span class="n">p0</span><span class="o">+</span><span class="n">light_dir</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">+</span><span class="n">h</span><span class="p">,</span> <span class="n">jp</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">hardness</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="n">t</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">shadow</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">fori_loop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">step_n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">light_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]))</span>
<span class="n">shadow</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">cast_shadow</span><span class="p">,</span> <span class="n">sdf</span><span class="p">,</span> <span class="n">light_dir</span><span class="p">))(</span><span class="n">hit_pos</span><span class="p">)</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">shadow</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
</pre></div>

<img src="05.jpeg"></code-cell><p>Now let's apply all lighting components, including the classical <a href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model">Blinn‚ÄìPhong</a> shading model. Note <a href="https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear">gamma correction</a> which is too often omitted even in professional software.</p>
<code-cell><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">shade_f</span><span class="p">(</span><span class="n">surf_color</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">raw_normal</span><span class="p">,</span> <span class="n">ray_dir</span><span class="p">,</span> <span class="n">light_dir</span><span class="p">):</span>
  <span class="n">ambient</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">raw_normal</span><span class="p">)</span>
  <span class="n">normal</span> <span class="o">=</span> <span class="n">raw_normal</span><span class="o">/</span><span class="n">ambient</span>
  <span class="n">diffuse</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">light_dir</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">*</span><span class="n">shadow</span>
  <span class="n">half</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light_dir</span><span class="o">-</span><span class="n">ray_dir</span><span class="p">)</span>
  <span class="n">spec</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">shadow</span> <span class="o">*</span> <span class="n">half</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="o">**</span><span class="mf">200.0</span>
  <span class="n">light</span> <span class="o">=</span> <span class="mf">0.7</span><span class="o">*</span><span class="n">diffuse</span><span class="o">+</span><span class="mf">0.2</span><span class="o">*</span><span class="n">ambient</span>
  <span class="k">return</span> <span class="n">surf_color</span><span class="o">*</span><span class="n">light</span> <span class="o">+</span> <span class="n">spec</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">shade_f</span><span class="p">,</span> <span class="n">jp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">light_dir</span><span class="o">=</span><span class="n">light_dir</span><span class="p">)</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">shadow</span><span class="p">,</span> <span class="n">raw_normal</span><span class="p">,</span> <span class="n">ray_dir</span><span class="p">)</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.2</span><span class="p">)</span>  <span class="c1"># gamma correction</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>

<img src="06.jpeg"></code-cell><p>For now, all surfaces in our scene have a uniform white color, but shading allows us to interpret 3D geometry from a 2D image. Let's now add some colors and simple textures. I modified the scene function to have a special mode where it also returns the surface color. The function computes colors for both balls and the surface, and then uses <code>jp.choose</code> to select the color for the current pixel. The overhead for computing both colors is negligible because we use this mode only once per ray (versus the sdf-only mode, which we evaluate 50 times for primary and 50 times for shadow rays).</p>
<code-cell><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scene_sdf</span><span class="p">(</span><span class="n">balls</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ball_r</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span> <span class="n">with_color</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="n">dists</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">balls</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span><span class="o">-</span><span class="n">ball_r</span>
  <span class="n">balls_dist</span> <span class="o">=</span> <span class="o">-</span><span class="n">jax</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">logsumexp</span><span class="p">(</span><span class="o">-</span><span class="n">dists</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">c</span>
  <span class="n">floor_dist</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">3.0</span>  <span class="c1"># floor is at y==-3.0</span>
  <span class="n">min_dist</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">balls_dist</span><span class="p">,</span> <span class="n">floor_dist</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">with_color</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">min_dist</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">jp</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="mf">20.0</span><span class="p">)</span>
  <span class="n">floor_color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">)</span><span class="o">*</span><span class="n">jp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="n">balls_color</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="o">-</span><span class="n">dists</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="o">@</span> <span class="n">balls</span><span class="o">.</span><span class="n">color</span>
  <span class="n">color</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">floor_dist</span> <span class="o">&lt;</span> <span class="n">balls_dist</span><span class="p">),</span>
            <span class="p">[</span><span class="n">balls_color</span><span class="p">,</span> <span class="n">floor_color</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">color</span>

<span class="n">color_sdf</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">scene_sdf</span><span class="p">,</span> <span class="n">balls</span><span class="p">,</span> <span class="n">with_color</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">surf_color</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">color_sdf</span><span class="p">)(</span><span class="n">hit_pos</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">shade_f</span><span class="p">,</span> <span class="n">light_dir</span><span class="o">=</span><span class="n">light_dir</span><span class="p">)</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">surf_color</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">raw_normal</span><span class="p">,</span> <span class="n">ray_dir</span><span class="p">)</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.2</span><span class="p">)</span>  <span class="c1"># gamma correction</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>

<img src="07.jpeg"></code-cell><h2>Performance, animation, differentiation</h2>
<p>That's it! With a moderate amount of code we got a shaded and colored scene. We rendered a single frame so far, but to create an animation we need to think about performance. JAX code can be made faster by using <code>@jit</code> decorator, which analyzes the flow of execution and generates the optimized code. Let's put everything together and JIT:</p>
<code-cell><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_render_scene</span><span class="p">(</span><span class="n">balls</span><span class="p">,</span>
                  <span class="n">view_size</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">400</span><span class="p">),</span>
                  <span class="n">target_pos</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]),</span>
                  <span class="n">camera_pos</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]),</span>
                  <span class="n">light_dir</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]),</span>
                  <span class="n">sky_color</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])):</span>
  <span class="n">sdf</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">scene_sdf</span><span class="p">,</span> <span class="n">balls</span><span class="p">)</span>
  <span class="n">normal_color_f</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">with_color</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">has_aux</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">light_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light_dir</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">render_ray</span><span class="p">(</span><span class="n">ray_dir</span><span class="p">):</span>
    <span class="n">hit_pos</span> <span class="o">=</span> <span class="n">raycast</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">camera_pos</span><span class="p">,</span> <span class="n">ray_dir</span><span class="p">)</span>
    <span class="n">shadow</span> <span class="o">=</span> <span class="n">cast_shadow</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">light_dir</span><span class="p">,</span> <span class="n">hit_pos</span><span class="p">)</span>
    <span class="n">raw_normal</span><span class="p">,</span> <span class="n">surf_color</span> <span class="o">=</span> <span class="n">normal_color_f</span><span class="p">(</span><span class="n">hit_pos</span><span class="p">)</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">shade_f</span><span class="p">(</span><span class="n">surf_color</span><span class="p">,</span> <span class="n">shadow</span><span class="p">,</span> <span class="n">raw_normal</span><span class="p">,</span> <span class="n">ray_dir</span><span class="p">,</span> <span class="n">light_dir</span><span class="p">)</span>
    <span class="n">escape</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hit_pos</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="mf">20.0</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">0.5</span>
    <span class="n">color</span> <span class="o">=</span> <span class="n">color</span> <span class="o">+</span> <span class="p">(</span><span class="n">sky_color</span><span class="o">-</span><span class="n">color</span><span class="p">)</span><span class="o">*</span><span class="n">escape</span>
    <span class="k">return</span> <span class="n">color</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.2</span><span class="p">)</span>  <span class="c1"># gamma correction</span>

  <span class="n">ray_dir</span> <span class="o">=</span> <span class="n">camera_rays</span><span class="p">(</span><span class="n">target_pos</span><span class="o">-</span><span class="n">camera_pos</span><span class="p">,</span> <span class="n">view_size</span><span class="p">)</span>
  <span class="n">color</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">render_ray</span><span class="p">)(</span><span class="n">ray_dir</span><span class="p">)</span>
  <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">view_size</span>
  <span class="k">return</span> <span class="n">color</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">render_scene</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">(</span><span class="n">_render_scene</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Compilation time:&#39;</span><span class="p">)</span>
<span class="n">frame</span><span class="o">=%</span><span class="n">time</span> <span class="n">render_scene</span><span class="p">(</span><span class="n">balls</span><span class="p">)</span><span class="o">.</span><span class="n">block_until_ready</span><span class="p">()</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
</pre></div>

<div class="output"><pre>Compilation time:
CPU times: user 1.33 s, sys: 16.2 ms, total: 1.35 s
Wall time: 1.27 s
</pre></div>
<img src="08.jpeg"></code-cell><p>The nested <code>render_ray</code> function computes the color of an individual pixel, so <code>vmap</code> is only applied once at the highest level. Rays that escape the scene are now colored with <code>sky_color</code>. I tried to use <code>jax.lax.cond</code> to skip shading these rays with conditional evaluation, but the performance I got (even for frames where most rays escaped) was even slightly worse than just evaluating everything and using algebra to select the resulting color. JAX <a href="https://github.com/google/jax/issues/2947">seems</a> to execute both branches, which, along with the fixed number of steps per ray, is another limitation of tensor-granular API.</p>
<p>The first call to <code>render_scene</code> triggers JIT compilation, which takes around a second (wall time). Note that using <code>fori_loop</code> is critical to keep compilation times low. Using a python loop makes compilation ~10x slower.</p>
<p>Performance measurements of the original and the jitted function on a Colab Pro kernel can be seen below. I randomize ball positions each call to make sure that rendering results are not cached somewhere (doesn't seem to make any difference, but just in case).</p>
<code-cell><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">random_balls</span><span class="p">():</span>
  <span class="n">key</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">PRNGKey</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mf">1e6</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">create_balls</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<span class="err">!</span><span class="n">nvidia</span><span class="o">-</span><span class="n">smi</span> <span class="o">-</span><span class="n">L</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">No JIT render time:&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">_render_scene</span><span class="p">(</span><span class="n">random_balls</span><span class="p">())</span><span class="o">.</span><span class="n">block_until_ready</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">JIT render time:&#39;</span><span class="p">)</span>
<span class="o">%</span><span class="n">timeit</span> <span class="n">render_scene</span><span class="p">(</span><span class="n">random_balls</span><span class="p">())</span><span class="o">.</span><span class="n">block_until_ready</span><span class="p">()</span>
</pre></div>

<div class="output"><pre>GPU 0: Tesla V100-SXM2-16GB (UUID: GPU-93287726-bf2c-4c83-523a-c79a19482475)

No JIT render time:
594 ms ¬± 7.07 ms per loop (mean ¬± std. dev. of 7 runs, 1 loop each)

JIT render time:
15.3 ms ¬± 70.3 ¬µs per loop (mean ¬± std. dev. of 7 runs, 100 loops each)
</pre></div>
</code-cell><p>We can see that JIT-compilation makes rendering a few tens of times faster! It is definitely worth the effort to make the code jit-compatible even if it means using fixed-size arrays and less convinient flow control. Our renderer can produce small frames (640x400) at interactive frame rates, so it shouldn't take long to generate an animation using the code we wrote. It would have been even faster if we were using GPU shader languages (e.g. GLSL) instead of JAX, because that would allow to terminate some rays early and release resources to work on harder rays.</p>
<p>Nevertheless, the approach described here has the benefit of using the same tools that are typically used to train differentiable models, so is perfectly viable e.g. for debugging and monitoring the training progress of simple particle systems. Let's make a little animation now.</p>
<code-cell><div class="highlight"><pre><span></span><span class="o">%%</span><span class="n">time</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span> 
                  <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">],</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">]])</span><span class="o">*</span><span class="mf">0.7</span>
<span class="n">color</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">float32</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.9</span><span class="p">]]</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="p">[[</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.3</span><span class="p">]]</span><span class="o">*</span><span class="mi">5</span> <span class="o">+</span> <span class="p">[[</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]]</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">jp</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="n">pos</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">pos</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">s0</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">balls</span><span class="o">=</span><span class="n">Balls</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">color</span><span class="p">),</span>
    <span class="n">camera_pos</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">7</span><span class="p">]),</span>
    <span class="n">light_dir</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

<span class="n">keys</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">s1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">balls</span><span class="o">=</span><span class="n">create_balls</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">R</span><span class="o">=</span><span class="mf">10.0</span><span class="p">),</span>
    <span class="n">camera_pos</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">15.0</span><span class="p">,</span><span class="mf">8.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">]),</span>
    <span class="n">light_dir</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">s2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">balls</span><span class="o">=</span><span class="n">create_balls</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">R</span><span class="o">=</span><span class="mf">10.0</span><span class="p">),</span>
    <span class="n">camera_pos</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">15.0</span><span class="p">,</span><span class="mf">9.0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">]),</span>
    <span class="n">light_dir</span><span class="o">=</span><span class="n">jp</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">cubic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
  <span class="n">s</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">-</span><span class="n">t</span>
  <span class="k">return</span> <span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">render_frame</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># easing</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">tree_map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">cubic</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">render_scene</span><span class="p">(</span><span class="o">**</span><span class="n">s</span><span class="p">)</span>

<span class="n">animate</span><span class="p">(</span><span class="n">render_frame</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>

<video controls loop>
 <source src="09.mp4" type="video/mp4">
 Your browser does not support the video tag.</video><div class="output"><pre>CPU times: user 12 s, sys: 1.41 s, total: 13.4 s
Wall time: 16.8 s
</pre></div>
</code-cell><p>The code above uses <code>jax.tree_map</code> to conveniently interpolate between nested data structures that contain information about the scene, including light and camera position.</p>
<p>Rendering a 10 second 60 fps animation takes from ~20 to less than 10 seconds depending on the available GPU (I tried V100 and A100, also running the first time in a Colab session takes a bit longer). Not bad for a ~100 lines of code engine built from scratch on top of the generic array processing language.</p>
<p>Oh, and did I mention that all JAX autodiff and vectorization goodies are still applicable? For example, nothing stops us from using forward AD to compute temporal derivatives of pixel color values, and then use them to make linear approximations of video frames around a particular moment of time. Note how adding and subtracting derivatives creates the illusion of motion, especially around specular highlights.</p>
<code-cell><div class="highlight"><pre><span></span><span class="n">img</span><span class="p">,</span> <span class="n">dimg</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jvp</span><span class="p">(</span><span class="n">render_frame</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.005</span><span class="p">,),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,))</span>
<span class="n">animate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">img</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">jp</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">dimg</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>

<video controls loop>
 <source src="10.mp4" type="video/mp4">
 Your browser does not support the video tag.</video></code-cell><h2>Conclusion</h2>
<p>I hope you enjoyed this little tutorial. Demosceners and shader developers probably wouldn't be impressed, but I hope it makes more ML developers aware of some less usual applications and capabilities of their tools.</p>
<p>Below you can find a few pointers to resources related to <em>SDF ray tracing</em> and <em>Differentiable Rendering</em> (and searching for these terms would give you many more).</p>
<ul>
<li><a href="https://iquilezles.org/articles/">Articles</a> and <a href="https://www.youtube.com/Inigo_Quilez">YouTube channel</a> by <a href="https://iquilezles.org/">Inigo Quilez</a></li>
<li><a href="https://www.shadertoy.com/">ShaderToy</a></li>
<li><a href="https://blog.evjang.com/2019/11/jaxpt.html">Differentiable Path Tracing on the GPU/TPU</a></li>
<li><a href="https://wandb.ai/wandb/nerf-jax/reports/Implementing-NeRF-in-JAX--VmlldzoxODA2NDk2">Implementing NeRF in JAX</a></li>
</ul>
<h3>Acknowledgements</h3>
<p>I'd like to thank my colleagues Johannes Oswald, Eyvind Niklasson and Ettore Randazzo for feedback and proofreading.</p>
